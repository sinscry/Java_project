1. Java基础：
    1. JDK和JRE的区别：
        1. JDK：Java Development Kit
        2. JRE: Java Runtime Environment
        3. JDK包含JRE，内含编译java源码的编译器javac
    
    2. equals和==的区别：
        1. ==判断内存空间是否一致，equals对值进行判断
    
    3. 两个对象的 hashCode()相同，则 equals()也一定为 true：
        1. 不对，但hashCode()不同，equals一定不同
        2. hashCode()运算更快，因此可以用来加快算法
    
    4. final在java中有什么用：
        1. 修饰类：该类不能继承
        2. 修饰方法：该类不能重写
        3. 修饰变量：表示变量只能一次赋值不能修改
        4. 本质：指向一个固定内存，内存中的值不能改变
    
    5. java 中的 Math.round(-1.5) ：
        1. +0.5再向下取整：-1.5 + 0.5 = -1
    
    6. String 不属于8种基础类型：
        1. byte: 8b
        2. short: 16b
        3. int: 32b
        4. long: 64b
        5. float: 32b
        6. double: 64b
        7. boolean: 1b
        8. char: 16b 
    
    7. java 中操作字符串都有哪些类：
        1. String：不可变对象，每次改变都会生成新的对象
        2. StringBuffer和StringBuilder是可以改变的对象
        3. 区别：
            1. 操作效率：StringBuilder>StringBuffer>String
            2. 线程安全：StringBuffer线程安全，可用于多线程
            3. StringBuilder是非线程安全，用于单线程
    
    8. String str="i" 与 String str=new String("i") 一样吗?:
        1. 不一样
            1. String str="i"的方式，Jvm将其分配常量池
            2. String str=new String("i")分配到堆内存 

    9. Java实现字符串反转：
        1. return new StringBuilder(str).reverse().toString();
        2. char[] chars = str.toCharArray();
        3. str.charAt(i)
    
    10. String类常用方法：
        1. indexOf()：返回字符索引
        2. charAt()：返回索引处字符
        3. replace()：字符串替换
        4. trim()：去除字符串两端空白
        5. split()：分割字符串
        6. getBytes()：返回字符串的byte类型数组
        7. substring()：截取字符串
        8. equals()：字符串比较
        9. length()：返回字符串长度
        10. toLowerCase()：字符串转小写
        11. toUpperCase()：字符串转大写

    11. 抽象类必须要有抽象方法吗?:
        1. 抽象类必须有关键字abstract修饰
        2. 抽象类可以不含有抽象方法
        3. 含抽象方法的必为抽象类
    
    12. 普通类和抽象类的区别
        1. 普通类不可含抽象方法
        2. 抽象类所有方法默认抽象方法，不可实例化，子类除非也是抽象类，否则必须声明抽象类声明的方法
        3. 抽象类不能使用final修饰

    13. 抽象类与接口的区别：
        1. 抽象类是从一些类中抽取出它们共有的属性
        2. 接口主要是对类的行为的抽象
        3. 一个类只能继承一个抽象类，一个类可以实现多个接口implements 接口
        4. 抽象类可以有构造方法
        5. 都不能被实例化，就是不能直接new()为它们分配空间
    
    14. java 中 IO 流分为几种：
        1. 流向划分：输入流和输出流
        2. 操作单元划分：字节流和字符流
        3. 流的角色划分：节点流和处理流
    
    15. BIO与NIO、AIO的区别：
        1. BIO：同步阻塞
        2. NIO：同步非阻塞
        3. AIO：异步非阻塞
    
    16. Files的常用方法：
        1. mkdir()
        2. mkdirs():多级文件夹
        3. delete()
        4. exists():是否存在
        5. isFile()：是否是文件
        6. list()

2. 容器
    1. java容器有哪些：
        1. 数组
        2. String
        3. java.util下的集合容器








1. HashMap:
    1. 继承于Map函数
    2. 线程不安全
    3. 可用null作key(table数组第一节点上)
    4. 初始容量16
    5. JDK1.8 采用数组+链表+红黑树

2. ArrayList和linkedList集合的区别：
    1. ArrayList: 自增长容量的数组，内存空间连续
    2. LinkList: 是双链表，不需要连续空间，大小不确定

3. 进程和线程的主要区别:
    1. 进程是操作系统资源分配的基本单位，线程是任务调度和执行的基本单位
    2. 进程有独立的代码和数据空间， 线程有独立的运行栈和程序计数器， 切换开销有差异
    3. OS能同时运行多进程，进程能同时多线程
    4. os为进程提供独特内存空间，除cpu外线程不提供内存空间，线程共享资源
    5. 线程是进程的部分，进程是线程的容器

4. 事务的ACID：
    1. Atomicity 原子性： 事务是不可分割的工作单位，要么全发生，要么不发生
    2. Consistency 一致性：事务前后数据的完整性必须一致
    3. Isolation 隔离性：多个并发事务之间要相互隔离，不被其他事务的操作数据所干扰
    4. Durability 持久性：事务提交对数据库数据改变是永久性的

5. 死锁：
    1. 死锁预防：
        1. 破坏"不可剥夺"条件：等待期间占有的资源被隐式的释放到系统的资源列表中
        2. 破坏"请求与保持条件"：
            1. 静态分配,进程开始执行时就申请所需要的全部资源
            2. 动态分配即每个进程在申请所需要的资源时他本身不占用系统资源
        3. 破坏"循环等待"条件：采用资源有序分配思想,申请资源按照编号顺序,小编号进程申请大编号进程

6. 事务4种隔离级别：
    1. Read uncommitted(读未提交)： 一事务写数据，其他事务只可读不可写该数据，（脏读问题）
    2. Read committed(读提交)： 写事务不可允许访问（不可重复读问题）
    3. Repeatable read(可重复读取)：事务未结束，其他事务不能访问该数据(读写)，同事务两次读数据一致。
    4. Serializable(可序化)： 事务顺序执行，不能并发执行

7. Java 基本数据类型：
    1. byte: 8b
    2. short: 16b
    3. int: 32b
    4. long: 64b
    5. float: 32b
    6. double: 64b
    7. boolean: 1b
    8. char: 16b 

8. 面向对象特征：
    1. 抽象：抽象是将一类对象的共同特征总结出来构造类的过程
    2. 封装：封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口
    3. 继承： 从已有类得到继承信息创建新类的过程
    4. 多态： 允许相同或不同子类型的对象对同一消息作出不同响应

9. 抽象类与接口的区别：
    1. 抽象类是从一些类中抽取出它们共有的属性
    2. 接口主要是对类的行为的抽象
    3. 一个类只能继承一个抽象类，一个类可以实现多个接口implements 接口
    4. 抽象类可以有构造方法
    5. 都不能被实例化，就是不能直接new()为它们分配空间

10. 重写与重载的区别：
    1. 重写(Override)：在子类中把父类本身有的方法重新写一遍
    2. 重载(Overload): 同名的方法如果有不同的参数列表（甚至是参数顺序不同）则视为重载

11. 线程安全：
    1. 共享数据的多条线程并行执行的程序中，线程安全代码通过同步机制保证各线程正确执行，不出现数据污染

12. 进程间通讯的四种方式:
    1. 共享内存：最快的方式
    2. 管道：管道用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。
    3. 信号：用于接受某种事件发生，进程还可以发送信号给进程本身，只有具备相同id的进程
    4. 消息队列是消息的链接表

13. UDP&TCP的区别
    1. 报头不同，特点不同，协议不同
    2. UDP:
        1. 数据报最大长64K（包含UDP首部）,超64K要在应用层手动分包，UDP无法保证包序，需在应用层编号。
        2. 无连接：知道对端的IP和端口号就直接进行传输, 不需要建立连接。
        3. 不可靠：没有确认机制, 没有重传机制;
        4. 面向数据报：应用层交给UDP多长的报文, UDP原样发送
        5. 协议：
            1. NFS:网络文件系统
            2. TFTP:简单文化传输协议
            3. DHCP：动态主机配置协议
            4. BOOTP：启动协议(动态主机配置协议)
            5. BOOTP：启动协议(用于无盘设备启动)
        6. 传输数据快

    3. TCP:
        1. 面向连接：
            1. 三次握手：
                1. A-》B SYN：通知B用哪个序列号作起始段回应
                2. B-》A ACK,SYN: 回应A已收到，并通知哪个序列号作起始回应
                3. A-》B ACK: 回应B收到回复，开始传输实际数据
            2. 四次挥手
                1. A-》B FIN=1：提出停止TCP连接
                2. B-》A ACK=1：确认单方向TCP连接关闭
                3. B-》A FIN=1：提出反方向关闭TCP
                4. A-》B ACK=1：确认双方向关闭

                5. 为什么要等待2MSL：
                    1. 保证客户端发送的最后一个ACK报文段能够到达服务器
                    2. 防止已失效的报文段骚扰服务器，使本链接持续时间内产生的所有报文段从网络中消失

        2. 点对点

        3. 协议：
            1. HTTP
            2. HTTPS
            3. SSH
            4. Telnet
            5. FTP
            6. SMTP